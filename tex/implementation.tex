\section{Implementation}
Activities are opened and closed by starting and finishing intents. In certain activities where the user should be able to return to the main menu and the main menu is not the previous activity on the stack, a new intent to the main menu is created with the added flag \verb|FLAG_ACTIVITY_CLEAR_TOP|. This brings the very first activity (\emph{MainActivity}) to the top and closes the others. Another used flag in the application is \verb|FLAG_ACTIVITY_NO_ANIMATION|, which removes the animation during the transition between \emph{PhotoActivity} and \emph{GameActivity}. To remove the animation when an activity is closed, the finish() method is overridden with the added line “overridePendingTransition(0, 0)”. \newline

The only activity that starts with startActivityForResult() is the camera application. When a photo is taken, onActivityResult() is called with a request code, a result code and data. If the request code and result code are correct, a new intent to \emph{GameActivity} is created with the data added as extra data. In \emph{GameActivity}, the data can now be used to get the photo that the user has taken and apply it to the bonus card. The application checks whether the user has taken a photo or wants to use the default card with getStringExtra(). \newline

A String key word is used to determine the type of gesture that the user has performed in \emph{GameActivity}. A down swipe has the key “keep”, an up swipe has the key “skip”, and double tap has either the key “bonus” or “rush” since double tap is used for both bonus cards and the rush hour card.  The \emph{VerifyFragment} class creates an interface that makes it possible to interact with the \emph{GameActivity} class, in order to update the score, the current card and the reference card. These images are then sent through the AsyncTask where the photos' IDs are compared. If the images share the same ID and the key is "keep, the integer `addPoints' is set to 1 and the boolean `updateAllCards' is set to true. If the images are not the same and the key is "keep", `addPoints' is set to -1 and `updateAllCards' is set to false. After imageMatch() is completed `addPoints' and `updateAllCards' will be sent back to \emph{GameActivity} and the score and cards are updated accordingly. If the key is “skip”, `addPoints' will be set to 0 and `updateAllCards' is set to false. If the key is “bonus”, `addPoints' is set to 5 and `updateAllCards' to true, and if the key is “rush”, the ''Rush Hour'' mode starts. Within this game mode, `addPoints' will be set to 1 and `updateAllCards' to false whether the key is "keep" or "skip". \newline

In \emph{FinishDialogFragment} an AlertDialog.Builder is used to built a dialog. The dialog has different text fields and buttons depending on the score that the user has achieved during the game. If the score is a highscore the text is set to “Congratulations! You made your highscore“ or “Congratulations! You beat your highscore” if it is the highest high score. If the score is a high score an editText box is added to the dialog where the user can enter his or her name and a submit button that will store the score and the name in a SharedPreferences when pressed. If the score is not a high score the message text is set to “You scored: XX score”.
\emph{FinishDialogFragment} also uses an interface to interact with \emph{GameActivity} if the user presses the start button. \newline

The \emph{Image} class extends the ImageView class, where we have overwritten the constructor so it accepts a custom ID, an image resource or bitmap, a bonus boolean and a rush hour boolean. The remaining functions in the \emph{Image} class are getter methods for use with \emph{GameActivity}, \emph{GestureListener} and \emph{VerifyFragment}. getDrawImage() returns the image resource stored within the object and getBitmap() returns the bitmap. In \emph{GameActivity}, getBitmap() is used to check if an image has a bitmap that can be used as a resource, otherwise it will use getDrawImage(). isBonus() and isRush() are used to access the corresponding booleans from the \emph{GestureListener}. getID() is used in \emph{VerifyFragment} to get two images in the \emph{Image} array’s ID for the idMatch() check. \newline

The \emph{GestureListener} class extends \verb|GestureDetector.SimpleOnTouchListener|, \\ which implements two types of gestures: fling and double tap. onFling() checks what type of swipe the user has performed. If it is a topSwipe, \emph{VerifyFragment}'s starts() method is called with the key “skip”. If it is a bottomSwipe, \emph{VerifyFragment}'s starts() method is called with the key “keep”. The topSwipe and bottomSwipe check if the difference between the coordinates from the two events is greater than 120 and the velocity is greater than 200. The only difference between the two methods is the order in which the numbers appear in the subtraction. onDoubleTap() checks if \emph{GameActivity}’s current image is a bonus card or a ''Rush Hour'' card. If the `bonus' boolean is true \emph{VerifyFragments}'s start() method is called with the key “bonus”. If the `rush' boolean is true, the start() method is called with the key “rush”. \newline

In \emph{HighscoreActivity} a top 5 list is shown with the five highest scores since the last time the list was reset. The highscore is kept in a SharedPreferences-class to make sure that the scores still appear even when destroying and recreating the application. The SharedPreferences keep the information as key-value pairs. These pairs have a key to both the names and the points. All the keys is saved in two arrays in \emph{HighscoreActivity}, a string array for the names and a integer array for the points.
The methods in \emph{GameActivity} involving the highscore save the highscore retrieved from \emph{FinishDialogFragment}, and decides whether the score can make it into the highscore board or not. The method getMinKey() returns the key to the lowest score to replace, so that only the 5 highest scores are saved in the SharedPreferences.
Every time \emph{HighScoreActivity} is entered, the activity updates the arrays with the names and points, so the values of the index in the arrays match the ranking. For this an “insertion sort”-algorithm is used to sort the arrays. These arrays are then shown as TextViews in a GridLayout in the \verb|activity_highscore.xml| file.
The reset button clears the editor in the specific SharedPreference class and calls onResume() to update the view.  \newline

\emph{InstructionsActivity} displays a background image, a menu title, an image with the instructions, a text to the corresponding image, an image number, and a back button. It contains an array of eight different images and an array with image text strings. The initial image is the first image in the array. When swiping left, the next image in the array is displayed if the last image has not been reached. Swiping right displays the previous image if the first image is not being displayed. The gesture detection is set up in gestureHandlingSetup(). The swipe is detected in the \emph{CustomGestureDetector} class, which extends \verb|GestureDetector.SimpleOnTouchListener|. When the detected horizontal swipe distance and speed are greater than certain values, the image number increases or decreases and the update method is called, setting the correct image, the correct image text, and image number. \newline

\newpage
The timer is implemented as a CountDownTimer with the time set to 60 seconds. The TextView showing the time is updated in the timer’s OnTick() method.  When the timer reaches 0, \emph{FinishDialogFragment} appears and the game is over. However, if the ''Rush Hour'' card is double tapped, the boolean `rushTime' is set to true. If the boolean `rushTime' is true, the TextView will count down from 5 seconds while the timer is still running as before - that is, the actual time might be more or less than 5 seconds. When the changed TextView hits 0, the TextView shows the actual time from the timer with 7 seconds in addition. The TextView therefore shows 7 seconds more than the actual time that is left. This makes it look like two different timers where the first timer continues after the second timer has ended. After the actual timer terminates - which happens before the TextView reaches 0 - a new timer is created to show the remaining seconds until the TextView reaches 0. This was done since having two timers run at the same time caused the application to crash.



