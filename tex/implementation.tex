\section{Implementation}
Activities are opened and closed by starting and finishing intents. In certain activities where the user should be able to return to the main menu and the main menu is not the previous activity on the stack, a new intent to the main menu is created with the added flag \verb|FLAG_ACTIVITY_CLEAR_TOP|. This brings the very first activity (MainActivity) to the top and closes the others. Another used flag in the application is \verb|FLAG_ACTIVITY_NO_ANIMATION|, which removes the animation during the transition between PhotoActivity and GameActivity. To remove the animation when an activity is closed, the ‘finish’ method is overridden with the added line “overridePendingTransition(0, 0)”. \newline

The only activity that is started with startActivityForResult is the camera application. When a photo is taken, onActivityResult is called with a request code, a result code and data. If the request code and result code are correct, a new intent to GameActivity is created with the data added as extra data. In GameActivity, the data can now be used to get the photo that the user has taken and apply it to the bonus card. The application checks whether the user has taken a photo or wants to use the default card with getStringExtra. \newline

<<<<<<< HEAD
A key word is used to determine the type of gesture that the user has performed in GameActivity. A down swipe has the key “keep”, an up swipe has the key “skip”, and double tap has either the key “bonus” or “rush” since double tap is used for both bonus cards and the rush hour card.  The VerifyFragment class creates an interface that makes it possible to interact with the GameActivity class, in order to update the score, the current photo and the reference photo. These images are then sent through the AsyncTask where the photos' IDs are compared. If the images share the same ID and the key is "keep, the integer addPoints is set to 1 and the boolean updateAllCards is set to true. If the images are not the same and the key is "keep" addPoints is set to -1 and updateAllCards is set to false. After the imageMatch is completed addPoints and updateAllCards will be sent back to GameActivity and the score and cards are updated accordingly. If the key is “skip” addPoints will be set to 0 and updateAllCards is set to false. If the key is “bonus” addPoints is set to 5 and updateAllCards to true, and if the key is “rush” the rush hout mode starts. Within this game mode, addPoints will be set to 1 and updateAllCards to false whether the key is "keep" or "skip". \newline

In the FinishDialogFragment an AlertDialog.Builder is used to built a dialog. The dialog has different text and buttons depending on the score that the user has achieved during the game. If the score is a high score the text is set to “Congratulations! You made your highscore“ or “Congratulations! You beat your highscore” if it is the highest high score. If the score is a high score an editText box is added to the dialog where the user can enter his or her name and a submit button that will store the score and the name in a SharedPreferences when pressed. If the score is not a high score the message text is set to “You scored: XX score”.
The FinishDialogFragment also uses an interface to interact with GameActivity if the user presses the start button. \newline

The Image class extends the ImageView class, where we have overwritten the constructor so it accepts a custom ID, an image resource or bitmap, a bonus boolean and a rush hour boolean. The remaining functions within the Image class are getter methods for usage with GameActivity, GestureListener and VerifyFragment. getDrawImage() returns the image resource stored within the object and getBitmap() returns the bitmap. In the GameActivity getBitmap is used as a check if an image has a bitmap that can be used as a resource and uses it for resources, otherwise it will use getDrawImage(). isBonus() and isRush() are used to access the corresponding booleans for usage in the GestureListener to check if the card is a rush or bonus card. getID() is used with the VerifyFragment to get two Images in the Image array’s ID for the idMatch check. \newline

The GestureListener class extends GestureDetector.SimpleOnTouchListener that implements two types of gestures fling and double tap. onFling() method checks what type of swipe the user has used. If it is a topSwipe, the VerifyFragment starts() method is called with the key “skip”. Else if it is a bottomSwipe, the VerifyFragment starts() method is called with the key “keep”. The topSwipe and bottomSwipe check if the difference between the coordinates from the two events is greater than 120 and the velocity is greater than 200. The only difference between the two methods is the subtraction between the two events. onDoubleTap checks if GameActivity’s current image is a bonus card or a rush hour card. If the bonus boolean is true the VerifyFragments start() method is called with the key “bonus”. If the rush boolean is true the start() method is called with the key “rush”. \newline

In HighscoreActivity a top 5 list is shown with the five highest scores since the last time the list was reset. The highscore is kept in a SharedPreferences-class to make sure that the scores still appear even when destroying and creating the application. The SharedPreferences keep the information as key-value pairs. These pairs have a key to both the name and the points that determines the place in the highscore and if it is a name or score. For example, the key “name1” will be the name of the first place in the highscore, and the key “point5” will be the points of the fifth place in the highscore. These keys match the ID of each TextView shown in the \verb|activity_highscore.xml| file. The methods in GameActivity involving the highscore saves the highscore gained from FinishDialogFragment, and decides if the score makes the highscore board. The method getMinKey() returns the key to the lowest score to replace, so that it only is the top 5 scores that is in the SharedPreferences. 
Every time the HighScoreActivity is called, the activity updates the names and points, so the values of the specific keys match the ranking. For this an “insertion sort”-algorithm is used to sort the points, and both sorted names and points are saved in two separate arrays. These arrays are then shown as TextViews in a GridLayout in the \verb|activity_highscore.xml| file.
The reset button clears the Editor in the specific SharedPreference-class and calls onResume to update the view.  \newline

The InstructionsActivity displays a background image, a menu title, an image with the instructions, a text to the corresponding image, an image number, and a back button. It contains an array of eight different images and an array with strings corresponding to each image, displaying only one image and one string at a time. The initial image is the first image in the array. When swiping left, the next image in the array is displayed if the last image has not been reached. Swiping right displays the previous image if the first image is not being displayed. The gesture detection is set up via gestureHandling. The swipe is detected via the CustomGestureDetector class, which extends GestureDetector.SimpleOnGestureListener. When the detected horizontal swipe distance and speed are greater than certain values, the corresponding methods increase or decrease the image number in the array and the update method is called, setting the correct image, the correct image text, and image number. \newline

\newpage
The timer is implemented as a CountDownTimer with the time set to 60 seconds. The text view showing the time is updated in the timer’s ‘OnTick’-method.  When the timer reaches 0, the FinishDialogFragment appears and the game is over. However, if the rush hour card is double tapped, the boolean rushTime is set to true. If the boolean rushTime is true, the text view will count down from 5 seconds while the timer is still running as before - that is, the actual time might be more or less than 5 seconds. When the changed TextView hits 0, the TextView shows the actual time from the timer with 7 seconds in addition. The TextView therefor shows 7 seconds more than the actual time that is left. This makes it look like two different timers where the first timer continues after the second timer has ended. After the actual timer terminates - which happens before the TextView reaches 0. This was done since having two timers run at the same time caused the application to crash.



